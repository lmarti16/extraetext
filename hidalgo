# ============================================================
# HIDALGO 2025 | Municipio (Artículo 1) + Total de Ingresos
# - Detecta MULTIPLES municipios por PDF (3-4 típicamente)
# - Corta cada bloque por el siguiente "Artículo 1" para no mezclar
# ============================================================

# install.packages(c("pdftools","stringr","dplyr","purrr","tibble","openxlsx"), dependencies = TRUE)

suppressPackageStartupMessages({
  library(pdftools)
  library(stringr)
  library(dplyr)
  library(purrr)
  library(tibble)
  library(openxlsx)
})

dir_pdfs <- "C:/Users/lmart/Downloads/Leyes Ingreso/hidalgo/2025"
out_xlsx <- file.path(dir_pdfs, "HIDALGO_2025__municipio_total_ingresos.xlsx")
out_csv  <- file.path(dir_pdfs, "HIDALGO_2025__municipio_total_ingresos.csv")

pdfs <- list.files(dir_pdfs, pattern = "\\.pdf$", full.names = TRUE, recursive = TRUE)

# ----------------------------
# Helpers
# ----------------------------
norm_ws <- function(x){
  x <- gsub("\r", "\n", x)
  x <- gsub("[ \t]+", " ", x)
  x <- gsub("\\s+", " ", x)
  trimws(x)
}

fix_spaced_numbers <- function(x){
  # 104 881 011.24 -> 104881011.24
  gsub("(?<=\\d)\\s+(?=\\d)", "", x, perl = TRUE)
}

to_num <- function(x){
  if (is.na(x) || !nzchar(x)) return(NA_real_)
  x <- fix_spaced_numbers(x)
  x <- gsub("[,$ ]", "", x)
  suppressWarnings(as.numeric(x))
}

# Artículo 1 / Primero / 1o / 1°
rx_art1 <- regex("(?i)art[ií]culo\\s*(?:1|primero|1\\s*o|1\\s*º|1\\s*°)\\s*[\\.-]?", dotall = TRUE)

# Municipio de X
rx_muni <- regex("(?i)municipio\\s+de\\s+([^,;\\.\\n]{3,120})", dotall = TRUE)

# Año
rx_year <- regex("(?i)ejercicio\\s+fiscal\\s+de\\s+(20\\d{2})", dotall = TRUE)

# Total ingresos + monto
rx_total <- regex(
  paste0(
    "(?i)(?:",
    "total\\s*(?:,\\s*)?(?:estimado\\s+de\\s+)?ingresos",
    "|suma\\s+total\\s+de\\s+los\\s+ingresos",
    "|total\\s+de\\s+ingresos",
    "|total\\s+general",
    "|gran\\s+total",
    ")\\s*[:\\-]?\\s*\\$?\\s*([0-9]{1,3}(?:[ ,][0-9]{3})*(?:\\.[0-9]{2})?|[0-9]+(?:\\.[0-9]{2})?)"
  ),
  dotall = TRUE
)

# Mapear posición -> página usando marcadores <<<P0001>>>
page_from_pos <- function(pos, mark_starts){
  if (is.na(pos)) return(NA_integer_)
  findInterval(pos, mark_starts)
}

extract_from_pdf_v2 <- function(pdf_path, max_block_chars = 300000){
  pages <- tryCatch(pdf_text(pdf_path), error = function(e) character(0))
  if (!length(pages)) {
    return(tibble(
      pdf = basename(pdf_path), pdf_path = pdf_path,
      law_idx = NA_integer_, page_articulo = NA_integer_,
      anio = NA_character_, municipio = NA_character_,
      total_str = NA_character_, total_num = NA_real_, page_total = NA_integer_,
      note = "No pude leer texto (pdf_text falló). ¿Escaneado?"
    ))
  }

  # normaliza páginas (sin perder contenido)
  pages_n <- vapply(pages, norm_ws, character(1))

  # arma texto completo con marcadores de página
  full_parts <- sprintf("<<<P%04d>>> %s", seq_along(pages_n), pages_n)
  full <- paste(full_parts, collapse = "\n\n")

  # posiciones de marcadores
  marks <- str_locate_all(full, "<<<P\\d{4}>>>")[[1]]
  mark_starts <- marks[,1]

  # localiza TODOS los Artículo 1
  locs <- str_locate_all(full, rx_art1)[[1]]
  if (!nrow(locs)) {
    # Diagnóstico: muestra si al menos hay "articulo" en el texto
    has_any_art <- str_detect(full, regex("(?i)art[ií]culo"))
    return(tibble(
      pdf = basename(pdf_path), pdf_path = pdf_path,
      law_idx = NA_integer_, page_articulo = NA_integer_,
      anio = NA_character_, municipio = NA_character_,
      total_str = NA_character_, total_num = NA_real_, page_total = NA_integer_,
      note = if (has_any_art) "No encontré 'Artículo 1/Primero' (pero sí hay 'Artículo')." else "No hay texto detectable (posible escaneo)."
    ))
  }

  # corta bloques: cada Art1 hasta el siguiente Art1 (para separar municipios)
  starts <- locs[,1]
  ends <- c(starts[-1] - 1, nchar(full))
  ends <- pmin(ends, starts + max_block_chars)  # safety

  out <- vector("list", length(starts))

  for (i in seq_along(starts)){
    block <- substr(full, starts[i], ends[i])

    # municipio: mejor buscar "Municipio de ..." relativamente cerca del inicio del bloque
    head_block <- substr(block, 1, 6000)

    muni_m <- str_match(head_block, rx_muni)
    muni <- if (!is.na(muni_m[1,2])) trimws(muni_m[1,2]) else NA_character_

    yr_m <- str_match(head_block, rx_year)
    anio <- if (!is.na(yr_m[1,2])) yr_m[1,2] else NA_character_

    # total: puede estar más adelante dentro del bloque
    block2 <- fix_spaced_numbers(block)
    tot_m <- str_match(block2, rx_total)

    total_str <- if (!is.na(tot_m[1,2])) tot_m[1,2] else NA_character_
    total_num <- to_num(total_str)

    # page articulo
    page_art <- page_from_pos(starts[i], mark_starts)

    # page total (si encontramos posición exacta del match)
    page_tot <- NA_integer_
    if (!is.na(total_str)) {
      tot_loc <- str_locate(block2, rx_total)
      if (!any(is.na(tot_loc))) {
        abs_pos_tot <- starts[i] + tot_loc[1] - 1
        page_tot <- page_from_pos(abs_pos_tot, mark_starts)
      }
    }

    out[[i]] <- tibble(
      pdf = basename(pdf_path),
      pdf_path = pdf_path,
      law_idx = i,
      page_articulo = page_art,
      anio = anio,
      municipio = muni,
      total_str = total_str,
      total_num = total_num,
      page_total = page_tot,
      note = case_when(
        is.na(muni) ~ "Municipio no encontrado cerca de Artículo 1 (revisar formato).",
        is.na(total_num) ~ "Total no encontrado dentro del bloque (quizá está más adelante o distinto texto).",
        TRUE ~ ""
      )
    )
  }

  bind_rows(out) |>
    # quita falsos positivos donde municipio es muy corto o basura
    mutate(
      municipio = ifelse(!is.na(municipio), str_squish(municipio), municipio)
    ) |>
    filter(is.na(municipio) | nchar(municipio) >= 4)
}

# ----------------------------
# RUN
# ----------------------------
res <- map_dfr(pdfs, extract_from_pdf_v2)

# dedup: a veces se repite por headers
res <- res |>
  distinct(pdf, municipio, total_num, .keep_all = TRUE) |>
  arrange(pdf, law_idx)

write.xlsx(list(EXTRACCION = res), out_xlsx, overwrite = TRUE)
write.csv(res, out_csv, row.names = FALSE, fileEncoding = "UTF-8")

print(res)
cat("\nLISTO:\n", out_xlsx, "\n", out_csv, "\n", sep="")
